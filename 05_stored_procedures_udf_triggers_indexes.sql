-- STORED PROCEDURES

-- Put relevant database to use
use sakila

-- Create a stored procedure that takes a category name as input and returns all films in that category, along with their rental rate and length.
create procedure GetFilmsByCategory
	@CategoryName varchar(50)
as
begin
	select
		f.title as 'Film Title',
		f.rental_rate as 'Rental Rate',
		f.length as 'Film Length'
	from film f
	inner join film_category fc on fc.film_id = f.film_id
	inner join category c on c.category_id = fc.category_id
	where c.name = @CategoryName
	order by f.title
end

EXEC GetFilmsByCategory 'Action' -- or 

EXEC GetFilmsByCategory @CategoryName = 'Comedy'

-- Create a stored procedure that finds the top N customers by total payment in a given country.
create procedure GetTopCustomersByCountry
	@CountryName varchar(50),
	@TopN int
as
begin
select TOP (@TopN)
	co.country as ' Country Name' , 
	c.first_name + ' ' + c.last_name as 'Customer Name',
	SUM(p.amount) as 'Total Payment'
from customer c
inner join payment p on p.customer_id = c.customer_id
inner join address a on a.address_id = c.address_id
inner join city ci on ci.city_id = a.city_id
inner join country co on co.country_id = ci.country_id
where co.country = @CountryName
group by co.country , c.first_name , c.last_name
order by  [Total Payment] desc
end

EXEC GetTopCustomersByCountry 'India', 3

-- User Defined Functions (UDFs)

-- SCALAR UDF
-- Create a scalar function that returns the total number of films an actor has appeared in.
create function f_GetFilmCountByActor (@ActorID int)
returns int
as 
begin
	declare @FilmCount int

	select @FilmCount = COUNT(*)
	from film_actor
	where actor_id = @ActorID

	return @FilmCount
	
end

select dbo.f_GetFilmCountByActor(5) as FilmCount

-- Create a scalar function that calculates the total revenue generated by a given customer (sum of all payment amounts).
create function f_GetTotalRevenueByCustomer(@CustomerID int)
returns float
as
begin
	declare @TotalRevenue float

	select
		@TotalRevenue = SUM(payment.amount)
	from customer 
	inner join payment on payment.customer_id = customer.customer_id
	where customer.customer_id = @CustomerID
	group by customer.customer_id

	return @TotalRevenue
end

select dbo.f_GetTotalRevenueByCustomer(12) as Total_Spent

-- TABLE VALUED FUNCTIONS (TVFs)
-- Create an inline table-valued function that returns all films for a given actor
create function f_GetFilmsByActor(@ActorID int)
returns table
as
return
(select
	f.film_id as 'Fim ID' , 
	f.title as ' Film Title' , 
	f.release_year as 'Film Release Year' , 
	f.rental_rate as 'Film Rental Rate'
from film f
inner join film_actor fa on fa.film_id = f.film_id
where fa.actor_id = @ActorID)

select * from dbo.f_GetFilmsByActor(10)

-- Create a multi-statement table-valued function that returns all customers in a given country, along with their total payment amount.
CREATE FUNCTION f_GetCustomersByCountry ( @CountryName VARCHAR(50) )
RETURNS @CustomerPayments TABLE
(
    customer_id INT,
    customer_name VARCHAR(100),
    total_payment DECIMAL(10,2)
)
AS
BEGIN
    INSERT INTO @CustomerPayments
    SELECT 
        c.customer_id,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        SUM(p.amount) AS total_payment
    FROM customer c
    INNER JOIN address a ON c.address_id = a.address_id
    INNER JOIN city ci ON a.city_id = ci.city_id
    INNER JOIN country co ON ci.country_id = co.country_id
    INNER JOIN payment p ON c.customer_id = p.customer_id
    WHERE co.country = @CountryName
    GROUP BY c.customer_id, c.first_name, c.last_name;

    RETURN
END

select * from f_GetCustomersByCountry('India')

-- TRIGGERS

-- DDL Triggers
/*  

Scenario 1:
You want to monitor all structural changes (CREATE, ALTER, DROP) made to tables in your database.

Task:
Create a DDL trigger named tr_LogTableChanges that fires whenever a table is created, altered, or dropped, and inserts details into an 
audit table named DDL_Change_Log.

*/
-- Step 1 - Create Audit table
create table DDL_Change_Log
(event_type NVARCHAR(100),
object_name NVARCHAR(200),
changed_by NVARCHAR(100),
change_date DATETIME)

-- Step 2 - Create Trigger
create trigger tr_LogTableChanges
on DATABASE
for Create_Table , Alter_Table , Drop_Table
as
begin
set NOCOUNT on
insert into DDL_Change_Log (event_type , object_name , changed_by , change_date)
select
	EVENTDATA().value('(/EVENT_INSTANCE/EventType)[1]', 'NVARCHAR(100)'),
    EVENTDATA().value('(/EVENT_INSTANCE/ObjectName)[1]', 'NVARCHAR(200)'),
    EVENTDATA().value('(/EVENT_INSTANCE/LoginName)[1]', 'NVARCHAR(100)'),
    GETDATE()
end

/*  

Scenario 2:
You want to prevent accidental deletion of tables in the Production schema.

Task:
Create a DDL trigger named tr_PreventDropProductionTables that blocks any DROP TABLE command executed on tables under the Production schema and raises 
an error message saying: “Table drops are not allowed in the Production schema.”audit table named DDL_Change_Log.

*/

create trigger tr_PreventDropProductionTables
on DATABASE
for Drop_table
as
begin
	Declare @Schema NVARCHAR(200)
	Set @Schema = EVENTDATA().value('(/EVENT_INSTANCE/SchemaName)[1]' , 'NVARCHAR(200)')

	If @Schema = 'Production'
	Begin
		RAISERROR('Table drops are not allowed in the Production schema.', 16, 1)
		ROLLBACK
	End
end

-- DML Triggers
/*

Scenario 1:
You have two tables:
	payment — stores individual payments
	customer_summary — stores total amount paid per customer

Task:
Create a DML trigger named tr_UpdateCustomerSummary on the payment table that:
After each INSERT, updates the total amount in customer_summary.
If the customer doesn’t exist in customer_summary, insert a new record.

*/

-- Step 1: Example structure for customer_summary table
CREATE TABLE customer_summary (
    customer_id INT PRIMARY KEY,
    total_amount DECIMAL(10,2)
)

-- Step 2: Create the DML trigger
CREATE TRIGGER tr_UpdateCustomerSummary
ON payment
AFTER INSERT
AS
BEGIN
    SET NOCOUNT ON;

    MERGE customer_summary AS target
    USING (
        SELECT customer_id, SUM(amount) AS total_payment
        FROM inserted
        GROUP BY customer_id
    ) AS src
    ON target.customer_id = src.customer_id

    WHEN MATCHED THEN
        UPDATE SET target.total_amount = target.total_amount + src.total_payment

    WHEN NOT MATCHED THEN
        INSERT (customer_id, total_amount)
        VALUES (src.customer_id, src.total_payment);
END

/*

Scenario 2:
You want to track all salary updates in the employees table.

Task:
Create a DML trigger named tr_LogSalaryChanges that fires on UPDATE of the salary column and inserts a record into an employee_salary_audit table.

*/

-- Step 1: Create audit table
CREATE TABLE employee_salary_audit (
    employee_id INT,
    old_salary float,
    new_salary float,
    updated_by NVARCHAR(100),
    update_date DATETIME
)

-- Step 2: Create trigger
CREATE TRIGGER tr_LogSalaryChanges
ON employees
AFTER UPDATE
AS
BEGIN
    SET NOCOUNT ON;

    INSERT INTO employee_salary_audit (employee_id, old_salary, new_salary, updated_by, update_date)
    SELECT
        i.employee_id,
        d.salary AS old_salary,
        i.salary AS new_salary,
        SUSER_SNAME(),       -- captures username of updater
        GETDATE()
    FROM inserted i
    INNER JOIN deleted d ON i.employee_id = d.employee_id
    WHERE (i.salary <> d.salary) OR (i.salary IS NULL AND d.salary IS NOT NULL) OR (i.salary IS NOT NULL AND d.salary IS NULL)
END

-- INDEXING

-- NON CLUSTERED INDEX
-- Scenario - You often run queries to find films by their rating and sort them by their rental_rate. Optimize film searches.
create NONCLUSTERED INDEX ix_Film_Rating_RentalRate
on film (rating , rental_rate desc)
include (title)

-- Use case
select
	film_id,
	title,
	rental_rate
from film
where rating = 'PG'
order by rental_rate desc

-- FILTERED INDEX
-- Scenario - You frequently query films that are available for rent (i.e., have inventory) and are longer than 120 minutes.
create NONCLUSTERED INDEX ix_Film_LongFilms
on film (length)
where length > 120

-- Use case
select
	title,
	length
from film
where length > 120 and rental_duration > 3

-- MULTI-COLUMN INDEX (COMPOSITE INDEX)
-- Scenario - You often query total payments made by customers for a given date range. Optimize searches for the same.
create NONCLUSTERED INDEX ix_Payment_Store_Date
on payment (customer_id , payment_date)
include (amount)

-- Use case
select
	customer_id,
	SUM(amount) as 'Total Amount'
from payment
where payment_date between '2005-07-01' AND '2005-07-31'
group by customer_id

-- UNIQUE COMPOSITE INDEX 
-- Scenario - In the film_actor table, each actor can appear only once per film. Enforce this rule and speed up joins on both columns.
-- Create a unique composite index on the film_actor table to ensure no actor is linked to the same film more than once.
create UNIQUE INDEX ix_filmactor_film_actor
on film_actor (film_id , actor_id)

-- Use case
select
	f.title,
	a.first_name,
	a.last_name
from film f
inner join film_actor fa on f.film_id = fa.film_id
inner join actor a on fa.actor_id = a.actor_id
order by f.title